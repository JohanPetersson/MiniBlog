<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<post>
  <author>johan</author>
  <title>Cross publishing by mirroring, or?</title>
  <description />
  <content>&lt;h2&gt;The requirements&lt;/h2&gt;  &lt;p&gt;One of our clients has an enterprise solution with several websites in the same EPiServer database and wanted to be able to publish some content just once and then the content would be reflected on each website. But sometimes they wanted to create local content as well in the same page structure which was created by the global content. Sometimes parts of the content shouldn’t be reflected on all sites, just selected ones.&lt;/p&gt;  &lt;p&gt;The two latter requirements made the solution much more complex.&lt;/p&gt;  &lt;p&gt;[more]&lt;/p&gt;  &lt;h2&gt;The solution&lt;/h2&gt;  &lt;p&gt;If it wasn’t for the requirement to create local content too, the obvious solution would be a custom &lt;em&gt;Page Provider&lt;/em&gt;. So we started to investigate if mirroring suited our needs.&lt;/p&gt;  &lt;p&gt;We created a site called &lt;em&gt;Global Content&lt;/em&gt; which holds all the global content and then three test websites. Then we installed the mirroring service as a stand-alone application. We &lt;a href="http://world.episerver.com/Documentation/Items/Tech-Notes/EPiServer-CMS-6/EPiServer-CMS-60/Mirroring/"&gt;configured&lt;/a&gt; the mirroring service.&lt;/p&gt;  &lt;p&gt;We created a couple of mirroring channels and ran the scheduled job. It all worked just fine. Then we tested to create local pages where the mirroring service already created some pages, created some more global pages and then ran the job again. Everything worked just fine.&lt;/p&gt;  &lt;p&gt;To meet the requirement that not all sites should receive all, let’s say news articles, the editor could categorize the articles and then the news archive page just listed the selected categories.&lt;/p&gt;  &lt;p&gt;In production, the number of websites increased to about 10 and now we had about 30 mirroring channels. Things started to go bad. The mirroring service froze and the CPU utilized 100%! After a while we received a timeout. &lt;/p&gt;  &lt;p&gt;&lt;strong&gt;“The request channel timed out while waiting for a reply after 00:01:00. Increase the timeout value passed to the call to Request or increase the SendTimeout value on the Binding. The time allotted to this operation may have been a portion of a longer timeout.”&lt;/strong&gt;&lt;/p&gt;  &lt;p&gt;The error message suggested to beef up the timeout, so we did. But no luck there. We started to fiddle with all the other settings. &lt;/p&gt;  &lt;p&gt;&lt;a href="http://www.dodavinkeln.se/image.axd?picture=image.png"&gt;&lt;img class="left" alt="" src="http://www.dodavinkeln.se/image.axd?picture=image_thumb.png" width="244" height="168" /&gt;&lt;/a&gt;We noted there were a lot of requests to the service, and long lived ones. We read some &lt;a href="http://blogs.msdn.com/b/tmarq/archive/2007/07/21/asp-net-thread-usage-on-iis-7-0-and-6-0.aspx"&gt;articles about number of concurrent requests&lt;/a&gt; and changed the MaxConcurrentRequestsPerCPU to 5000.&lt;/p&gt;  &lt;p&gt;The developer support suggested some other changes, like closeTimeout, openTimeout, receiveTimeout, sendTimeout and maxConnections on the binding configuration.&lt;/p&gt;  &lt;p&gt;One thing to note is that there wasn’t much content which was mirrored, it seemed to be the number of channels that was causing the error. But we decreased the numberOfPagesInPackage setting.&lt;/p&gt;  &lt;p&gt;Nothing seemed to work.&lt;/p&gt;  &lt;p&gt;We also received “Error while unloading appdomain. (Exception from HRESULT: 0x80131015)” and “Exception: The ConnectionString property has not been initialized.[]”.&lt;/p&gt;  &lt;p&gt;Now we started to disable some channels so we were down to about 20 channels. Now the job started to work again, sometimes it even ran fast.&lt;/p&gt;  &lt;p&gt;OK, so mirroring doesn’t seem to work so well if you’re mirroring to the same server with a lot of channels. Now we looked in to do our custom scheduled job and execute each channel with some timespan between them, but after some digging with reflector that seemed like a huge task.&lt;/p&gt;  &lt;p&gt;So this wasn’t the solution after all. But it will work in some cases, and will probably be one part of our final solution where the target content should be exactly as the source but the editor should be able to create local pages.&lt;/p&gt;  &lt;p&gt;I remembered an old &lt;a href="http://world.episerver.com/Blogs/Anders-Hattestad/Dates/2011/1/PageProviders-and-DDS-a-match-from-heaven/"&gt;article from Anders Hattestad&lt;/a&gt; in which he used the &lt;em&gt;DDS&lt;/em&gt; and created a &lt;em&gt;Page Provider&lt;/em&gt; for local pages. Stay tuned for part 2 in this mini series, where we create a more sophisticated &lt;em&gt;Page Provider&lt;/em&gt; with some more settings.&lt;/p&gt;</content>
  <ispublished>True</ispublished>
  <iscommentsenabled>True</iscommentsenabled>
  <pubDate>2012-02-09 10:36:00</pubDate>
  <lastModified>2012-02-09 15:39:20</lastModified>
  <raters>0</raters>
  <rating>0</rating>
  <slug>cross-publishing-by-mirroring</slug>
  <tags>
    <tag>cross-publishing</tag>
    <tag>mirroring</tag>
  </tags>
	<comments />
  <categories>
    <category>EPiServer</category>
  </categories>
  <notifications>
    <email>melaagya175064@gmail.com</email>
  </notifications>
</post>